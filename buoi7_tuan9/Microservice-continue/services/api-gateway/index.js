const express = require('express');
const axios = require('axios');
const { default: axiosRetry } = require('axios-retry');  // Alternative import
const Bottleneck = require('bottleneck');
const CircuitBreaker = require('opossum');

const app = express();
app.use(express.json());

// === Rate Limiter (Client Side) using Bottleneck ===
const limiter = new Bottleneck({
    maxConcurrent: 2, // Limit concurrent requests
    minTime: 500 // 500ms between requests
});
// === Circuit Breaker ===
// === Circuit Breaker ===
function wrapWithBreaker(fn, name = "Service") {
    const breaker = new CircuitBreaker(async (...args) => {
        try {
            const result = await fn(...args);
            return result;
        } catch (error) {
            console.error(`‚ùå [${name}] Service failed: ${error.message}`);
            throw error;
        }
    }, {
        timeout: 3000, // Timeout for each request
        errorThresholdPercentage: 50, // Error threshold before circuit breaker trips
        resetTimeout: 10000, // Time to wait before resetting the breaker after opening
    });

    breaker.fallback(() => {
        console.warn(`‚ö†Ô∏è [${name}] Fallback triggered`);
        return { data: { message: `${name} Service temporarily unavailable (fallback)` } };
    });

    breaker.on('open', () => console.warn(`üî¥ [${name}] Circuit opened`));
    breaker.on('close', () => console.log(`üü¢ [${name}] Circuit closed`));
    breaker.on('halfOpen', () => console.log(`üü° [${name}] Circuit half-open`));

    return async (...args) => {
        return breaker.fire(...args); // No retry logic here
    };
}
// === Wrapped functions with Circuit Breaker ===
const callPaymentService = wrapWithBreaker(async (data) => {
    return await axios.post('http://localhost:3004/api/payments', data);
}, "Payment");

const callShippingService = wrapWithBreaker(async (data) => {
    return await axios.post('http://localhost:3003/api/shipments', data);
}, "Shipping");

// === New Route for Circuit Breaker Test ===
app.post('/test-circuit-breaker', async (req, res) => {
    const paymentData = {
        orderId: 'breaker-test',
        amount: 1000
    };

    const shippingData = {
        orderId: 'breaker-test',
        address: '123 Main St.'
    };

    try {
        console.log('test-circuit-breaker');
        console.log('üßæ Calling Payment Service...');
        const paymentResponse = await callPaymentService(paymentData);

        console.log('üöö Calling Shipping Service...');
        const shippingResponse = await callShippingService(shippingData); 
        res.json({
            payment: paymentResponse.data,
            shipment: shippingResponse.data
        });
    } catch (error) {
        console.error('‚ùå Final error after breaker handling:', error.message);
        res.status(500).json({ error: error.message || 'Something went wrong' });
    }
});


// === Retry Configuration ===
// === C·∫•u h√¨nh retry ===
let retryCounter = 0;
axiosRetry(axios, {
    retries: 3,
    retryDelay: (retryCount) => {
        retryCounter = retryCount;
        console.log(`üîÅ Retry attempt ${retryCount}/3`);
        return retryCount * 1000;
    },
    retryCondition: (error) => {
        return error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND' || error.response?.status >= 500;
    }
});


// === Route test ri√™ng r·∫Ω t·ª´ng l·∫ßn ===
app.post('/test-retry', async (req, res) => {
    const paymentData = {
        orderId: 'retry-test',
        amount: 1000
    };

    const shippingData = {
        orderId: 'retry-test',
        address: '123 Retry St.'
    };

    try {
        console.log('test-retry');
        console.log('üßæ [1] Calling Payment Service...');
        const paymentResponse = await axios.post('http://localhost:3001/api/payments', paymentData);
        console.log('‚úÖ Payment service success');

        console.log('üöö [2] Calling Shipping Service...');
        const shippingResponse = await axios.post('http://localhost:3004/api/shipments', shippingData);
        console.log('‚úÖ Shipping service success');

        res.json({
            payment: paymentResponse.data,
            shipment: shippingResponse.data
        });
    } catch (error) {
        console.error('‚ùå Final error after retries: ', error.message);
        res.status(500).json({ error: error.message });
    }
});


// === Circuit Breaker Wrapper ===
function wrapWithBreakerAndLimiter(fn, name = "Service") {
    const breaker = new CircuitBreaker(fn, {
        timeout: 3000,
        errorThresholdPercentage: 50,
        resetTimeout: 10000,
    });

    breaker.fallback(() => {
        return { data: { message: `${name} Service temporarily unavailable (fallback)` } };
    });

    breaker.on('open', () => console.log(`${name} Circuit opened`));
    breaker.on('close', () => console.log(`${name} Circuit closed`));
    breaker.on('halfOpen', () => console.log(`${name} Circuit half-open`));

    return async (...args) => {
        return limiter.schedule(() => breaker.fire(...args));
    };
}



const callInventoryService = wrapWithBreakerAndLimiter(async (data) => {
    return await axios.post('http://localhost:3002/api/inventory/update', data);
}, "Inventory");

// const callShippingService = wrapWithBreakerAndLimiter(async (data) => {
//     return await axios.post('http://shipping-service:3003/api/shipments', data);
// }, "Shipping");

// === Route ===
app.post('/api/orders', async (req, res) => {
    try {
        const payment = await callPaymentService({
            orderId: req.body.orderId,
            amount: req.body.amount
        });

        await callInventoryService({
            productId: req.body.productId,
            quantity: req.body.quantity
        });


        res.json({
            payment: payment.data,
        });
    } catch (error) {
        res.status(500).json({ error: error.message || 'Something went wrong' });
    }
});
// app.post('/test-retry', async (req, res) => {
//     const paymentData = {
//         orderId: 'retry-test',
//         amount: 1000
//     };

//     const shippingData = {
//         orderId: 'retry-test',
//         address: '123 Retry St.'
//     };

//     try {
//         const [paymentResponse, shippingResponse] = await Promise.all([
//             axios.post('http://payment-service:3001/api/payments', paymentData),
//             axios.post('http://shipping-service:3003/api/shipments', shippingData)
//         ]);

//         res.json({
//             payment: paymentResponse.data,
//             shipment: shippingResponse.data
//         });
//     } catch (error) {
//         console.error('Error during retry test:', error.message);
//         res.status(500).json({ error: error.message });
//     }
// });

// === C·∫•u h√¨nh Rate Limiter chi ti·∫øt ===
const rateLimiter = new Bottleneck({
    maxConcurrent: 2,     // S·ªë l∆∞·ª£ng request ƒë·ªìng th·ªùi t·ªëi ƒëa
    minTime: 1000,        // Th·ªùi gian t·ªëi thi·ªÉu gi·ªØa c√°c request (1 gi√¢y)
    highWater: 5,         // S·ªë request t·ªëi ƒëa trong h√†ng ƒë·ª£i
    strategy: Bottleneck.strategy.BLOCK // Ch·∫∑n request khi ƒë·∫°t gi·ªõi h·∫°n
});

// === C·∫•u h√¨nh Time Limiter ===
const TIME_LIMIT = 2000; // Gi·ªõi h·∫°n th·ªùi gian 2 gi√¢y cho m·ªói request

// === H√†m wrapper cho Time Limiter ===
const timeoutPromise = (promise, time) => {
    return Promise.race([
        promise,
        new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Request timeout')), time)
        )
    ]);
};

// === Route test Rate Limiter ===
app.post('/test-rate-limiter', async (req, res) => {

    try {
        // Th·ª±c hi·ªán request th√¥ng qua rate limiter
        const result = await rateLimiter.schedule(async () => {
            console.log('test-rate-limiter');
            console.log('üöÄ ƒêang x·ª≠ l√Ω request...' + new Date().toISOString());
            
            // Gi·∫£ l·∫≠p x·ª≠ l√Ω trong 500ms
            await new Promise(resolve => setTimeout(resolve, 500));
            
            return {
                timestamp: new Date().toISOString(),
                message: 'Request ƒë∆∞·ª£c x·ª≠ l√Ω th√†nh c√¥ng'
            };
        });

        res.json(result);
    } catch (error) {
        console.error('‚ùå L·ªói Rate Limiter:', error.message);
        res.status(429).json({ 
            error: 'Qu√° nhi·ªÅu request, vui l√≤ng th·ª≠ l·∫°i sau',
            details: error.message 
        });
    }
});

// === Route test Time Limiter ===
app.post('/test-time-limiter', async (req, res) => {
    try {
        // Gi·∫£ l·∫≠p m·ªôt service call v·ªõi time limit
        const serviceCall = new Promise((resolve) => {
            // Gi·∫£ l·∫≠p x·ª≠ l√Ω m·∫•t 3 gi√¢y (s·∫Ω v∆∞·ª£t qu√° time limit 2 gi√¢y)
            setTimeout(() => {
                resolve({ data: 'D·ªØ li·ªáu t·ª´ service' });
            }, 3000);
        });

        // √Åp d·ª•ng time limit
        console.log('test-time-limiter');
        const result = await timeoutPromise(serviceCall, TIME_LIMIT);
        res.json(result);
    } catch (error) {
        console.error('‚ùå L·ªói Time Limiter:', error.message);
        res.status(408).json({ 
            error: 'Request v∆∞·ª£t qu√° th·ªùi gian cho ph√©p',
            details: error.message 
        });
    }
});

// === Route test k·∫øt h·ª£p c·∫£ Rate v√† Time Limiter ===
app.post('/test-combined-limiters', async (req, res) => {
    try {
        const result = await rateLimiter.schedule(async () => {
            console.log('üéØ B·∫Øt ƒë·∫ßu x·ª≠ l√Ω request k·∫øt h·ª£p...');
            
            // G·ªçi service v·ªõi time limit
            return await timeoutPromise(
                axios.post('http://localhost:3001/api/payments', {
                    orderId: 'test-combined',
                    amount: 1000
                }),
                TIME_LIMIT
            );
        });

        res.json({
            success: true,
            data: result.data,
            message: 'Request th√†nh c√¥ng qua c·∫£ rate limit v√† time limit'
        });
    } catch (error) {
        console.error('‚ùå L·ªói khi x·ª≠ l√Ω request k·∫øt h·ª£p:', error.message);
        res.status(500).json({
            error: 'L·ªói khi x·ª≠ l√Ω request',
            type: error.message.includes('timeout') ? 'TIME_LIMIT' : 'RATE_LIMIT',
            details: error.message
        });
    }
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`API Gateway running on port ${PORT}`);
});